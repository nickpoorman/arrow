// Code generated by scalar.gen.go.tmpl. DO NOT EDIT.

package arrow

import (
	"fmt"
	"math"

	"github.com/apache/arrow/go/arrow/decimal128"
	"github.com/apache/arrow/go/arrow/float16"
	"github.com/apache/arrow/go/arrow/memory"
)

type BooleanScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value bool
}

func NewBooleanScalarInterface(value interface{}, dataType DataType) BooleanScalar {
	if value == nil {
		return NewBooleanScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case bool:
		return NewBooleanScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewBooleanScalarInterface unsupported value type: %T", v))
	}
}

func NewBooleanScalar(value bool, dataType DataType) BooleanScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Boolean
	}
	return BooleanScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewBooleanScalarInvalid(dataType DataType) BooleanScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Boolean
	}
	return BooleanScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewBooleanScalarPrimitive(value bool) BooleanScalar {
	return BooleanScalar{
		isValid:  true,
		dataType: FixedWidthTypes.Boolean,
		value:    value,
	}
}

func NewBooleanScalarBytes(value []byte, dataType DataType) BooleanScalar {
	return NewBooleanScalar(BooleanTraits.GetValue(value), dataType)
}

func (s BooleanScalar) Equals(other Scalar) bool {
	right, ok := other.(BooleanScalar)
	return ok && s.value == right.value
}

func (s BooleanScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s BooleanScalar) Value() bool {
	return s.value
}

func (s BooleanScalar) ValueUint32() uint32 {
	if s.value {
		return 1
	} else {
		return 0
	}
}
func (s BooleanScalar) ValueUint64() uint64 {
	if s.value {
		return 1
	} else {
		return 0
	}
}

func (s BooleanScalar) ValueBytes() []byte {
	b := make([]byte, 1)
	BooleanTraits.PutValue(b, s.value)
	return b
}

func (s BooleanScalar) PutValue(dst []byte) int {
	BooleanTraits.PutValue(dst, s.value)
	return 1
}

func (s BooleanScalar) ValueSize() int {
	return 1
}

func (s BooleanScalar) DataType() DataType {
	return s.dataType
}

func (s BooleanScalar) IsValid() bool {
	return s.isValid
}

type Int8Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int8
}

func NewInt8ScalarInterface(value interface{}, dataType DataType) Int8Scalar {
	if value == nil {
		return NewInt8ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case int8:
		return NewInt8Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewInt8ScalarInterface unsupported value type: %T", v))
	}
}

func NewInt8Scalar(value int8, dataType DataType) Int8Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Int8
	}
	return Int8Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewInt8ScalarInvalid(dataType DataType) Int8Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Int8
	}
	return Int8Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewInt8ScalarPrimitive(value int8) Int8Scalar {
	return Int8Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Int8,
		value:    value,
	}
}

func NewInt8ScalarBytes(value []byte, dataType DataType) Int8Scalar {
	return NewInt8Scalar(Int8Traits.GetValue(value), dataType)
}

func (s Int8Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int8Scalar)
	return ok && s.value == right.value
}

func (s Int8Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int8Scalar) Value() int8 {
	return s.value
}

func (s Int8Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Int8Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Int8Scalar) ValueBytes() []byte {
	b := make([]byte, 1)
	Int8Traits.PutValue(b, s.value)
	return b
}

func (s Int8Scalar) PutValue(dst []byte) int {
	Int8Traits.PutValue(dst, s.value)
	return 1
}

func (s Int8Scalar) ValueSize() int {
	return 1
}

func (s Int8Scalar) DataType() DataType {
	return s.dataType
}

func (s Int8Scalar) IsValid() bool {
	return s.isValid
}

type Int16Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int16
}

func NewInt16ScalarInterface(value interface{}, dataType DataType) Int16Scalar {
	if value == nil {
		return NewInt16ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case int16:
		return NewInt16Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewInt16ScalarInterface unsupported value type: %T", v))
	}
}

func NewInt16Scalar(value int16, dataType DataType) Int16Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Int16
	}
	return Int16Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewInt16ScalarInvalid(dataType DataType) Int16Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Int16
	}
	return Int16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewInt16ScalarPrimitive(value int16) Int16Scalar {
	return Int16Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Int16,
		value:    value,
	}
}

func NewInt16ScalarBytes(value []byte, dataType DataType) Int16Scalar {
	return NewInt16Scalar(Int16Traits.GetValue(value), dataType)
}

func (s Int16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int16Scalar)
	return ok && s.value == right.value
}

func (s Int16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int16Scalar) Value() int16 {
	return s.value
}

func (s Int16Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Int16Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Int16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	Int16Traits.PutValue(b, s.value)
	return b
}

func (s Int16Scalar) PutValue(dst []byte) int {
	Int16Traits.PutValue(dst, s.value)
	return 2
}

func (s Int16Scalar) ValueSize() int {
	return 2
}

func (s Int16Scalar) DataType() DataType {
	return s.dataType
}

func (s Int16Scalar) IsValid() bool {
	return s.isValid
}

type Int32Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int32
}

func NewInt32ScalarInterface(value interface{}, dataType DataType) Int32Scalar {
	if value == nil {
		return NewInt32ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case int32:
		return NewInt32Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewInt32ScalarInterface unsupported value type: %T", v))
	}
}

func NewInt32Scalar(value int32, dataType DataType) Int32Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Int32
	}
	return Int32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewInt32ScalarInvalid(dataType DataType) Int32Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Int32
	}
	return Int32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewInt32ScalarPrimitive(value int32) Int32Scalar {
	return Int32Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Int32,
		value:    value,
	}
}

func NewInt32ScalarBytes(value []byte, dataType DataType) Int32Scalar {
	return NewInt32Scalar(Int32Traits.GetValue(value), dataType)
}

func (s Int32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int32Scalar)
	return ok && s.value == right.value
}

func (s Int32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int32Scalar) Value() int32 {
	return s.value
}

func (s Int32Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Int32Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Int32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	Int32Traits.PutValue(b, s.value)
	return b
}

func (s Int32Scalar) PutValue(dst []byte) int {
	Int32Traits.PutValue(dst, s.value)
	return 4
}

func (s Int32Scalar) ValueSize() int {
	return 4
}

func (s Int32Scalar) DataType() DataType {
	return s.dataType
}

func (s Int32Scalar) IsValid() bool {
	return s.isValid
}

type Int64Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int64
}

func NewInt64ScalarInterface(value interface{}, dataType DataType) Int64Scalar {
	if value == nil {
		return NewInt64ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case int64:
		return NewInt64Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewInt64ScalarInterface unsupported value type: %T", v))
	}
}

func NewInt64Scalar(value int64, dataType DataType) Int64Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Int64
	}
	return Int64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewInt64ScalarInvalid(dataType DataType) Int64Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Int64
	}
	return Int64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewInt64ScalarPrimitive(value int64) Int64Scalar {
	return Int64Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Int64,
		value:    value,
	}
}

func NewInt64ScalarBytes(value []byte, dataType DataType) Int64Scalar {
	return NewInt64Scalar(Int64Traits.GetValue(value), dataType)
}

func (s Int64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int64Scalar)
	return ok && s.value == right.value
}

func (s Int64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int64Scalar) Value() int64 {
	return s.value
}

func (s Int64Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Int64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	Int64Traits.PutValue(b, s.value)
	return b
}

func (s Int64Scalar) PutValue(dst []byte) int {
	Int64Traits.PutValue(dst, s.value)
	return 8
}

func (s Int64Scalar) ValueSize() int {
	return 8
}

func (s Int64Scalar) DataType() DataType {
	return s.dataType
}

func (s Int64Scalar) IsValid() bool {
	return s.isValid
}

type Uint8Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint8
}

func NewUint8ScalarInterface(value interface{}, dataType DataType) Uint8Scalar {
	if value == nil {
		return NewUint8ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case uint8:
		return NewUint8Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewUint8ScalarInterface unsupported value type: %T", v))
	}
}

func NewUint8Scalar(value uint8, dataType DataType) Uint8Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Uint8
	}
	return Uint8Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewUint8ScalarInvalid(dataType DataType) Uint8Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Uint8
	}
	return Uint8Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewUint8ScalarPrimitive(value uint8) Uint8Scalar {
	return Uint8Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Uint8,
		value:    value,
	}
}

func NewUint8ScalarBytes(value []byte, dataType DataType) Uint8Scalar {
	return NewUint8Scalar(Uint8Traits.GetValue(value), dataType)
}

func (s Uint8Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint8Scalar)
	return ok && s.value == right.value
}

func (s Uint8Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint8Scalar) Value() uint8 {
	return s.value
}

func (s Uint8Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Uint8Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Uint8Scalar) ValueBytes() []byte {
	b := make([]byte, 1)
	Uint8Traits.PutValue(b, s.value)
	return b
}

func (s Uint8Scalar) PutValue(dst []byte) int {
	Uint8Traits.PutValue(dst, s.value)
	return 1
}

func (s Uint8Scalar) ValueSize() int {
	return 1
}

func (s Uint8Scalar) DataType() DataType {
	return s.dataType
}

func (s Uint8Scalar) IsValid() bool {
	return s.isValid
}

type Uint16Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint16
}

func NewUint16ScalarInterface(value interface{}, dataType DataType) Uint16Scalar {
	if value == nil {
		return NewUint16ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case uint16:
		return NewUint16Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewUint16ScalarInterface unsupported value type: %T", v))
	}
}

func NewUint16Scalar(value uint16, dataType DataType) Uint16Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Uint16
	}
	return Uint16Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewUint16ScalarInvalid(dataType DataType) Uint16Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Uint16
	}
	return Uint16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewUint16ScalarPrimitive(value uint16) Uint16Scalar {
	return Uint16Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Uint16,
		value:    value,
	}
}

func NewUint16ScalarBytes(value []byte, dataType DataType) Uint16Scalar {
	return NewUint16Scalar(Uint16Traits.GetValue(value), dataType)
}

func (s Uint16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint16Scalar)
	return ok && s.value == right.value
}

func (s Uint16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint16Scalar) Value() uint16 {
	return s.value
}

func (s Uint16Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Uint16Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Uint16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	Uint16Traits.PutValue(b, s.value)
	return b
}

func (s Uint16Scalar) PutValue(dst []byte) int {
	Uint16Traits.PutValue(dst, s.value)
	return 2
}

func (s Uint16Scalar) ValueSize() int {
	return 2
}

func (s Uint16Scalar) DataType() DataType {
	return s.dataType
}

func (s Uint16Scalar) IsValid() bool {
	return s.isValid
}

type Uint32Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint32
}

func NewUint32ScalarInterface(value interface{}, dataType DataType) Uint32Scalar {
	if value == nil {
		return NewUint32ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case uint32:
		return NewUint32Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewUint32ScalarInterface unsupported value type: %T", v))
	}
}

func NewUint32Scalar(value uint32, dataType DataType) Uint32Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Uint32
	}
	return Uint32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewUint32ScalarInvalid(dataType DataType) Uint32Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Uint32
	}
	return Uint32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewUint32ScalarPrimitive(value uint32) Uint32Scalar {
	return Uint32Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Uint32,
		value:    value,
	}
}

func NewUint32ScalarBytes(value []byte, dataType DataType) Uint32Scalar {
	return NewUint32Scalar(Uint32Traits.GetValue(value), dataType)
}

func (s Uint32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint32Scalar)
	return ok && s.value == right.value
}

func (s Uint32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint32Scalar) Value() uint32 {
	return s.value
}

func (s Uint32Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Uint32Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Uint32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	Uint32Traits.PutValue(b, s.value)
	return b
}

func (s Uint32Scalar) PutValue(dst []byte) int {
	Uint32Traits.PutValue(dst, s.value)
	return 4
}

func (s Uint32Scalar) ValueSize() int {
	return 4
}

func (s Uint32Scalar) DataType() DataType {
	return s.dataType
}

func (s Uint32Scalar) IsValid() bool {
	return s.isValid
}

type Uint64Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint64
}

func NewUint64ScalarInterface(value interface{}, dataType DataType) Uint64Scalar {
	if value == nil {
		return NewUint64ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case uint64:
		return NewUint64Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewUint64ScalarInterface unsupported value type: %T", v))
	}
}

func NewUint64Scalar(value uint64, dataType DataType) Uint64Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Uint64
	}
	return Uint64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewUint64ScalarInvalid(dataType DataType) Uint64Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Uint64
	}
	return Uint64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewUint64ScalarPrimitive(value uint64) Uint64Scalar {
	return Uint64Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Uint64,
		value:    value,
	}
}

func NewUint64ScalarBytes(value []byte, dataType DataType) Uint64Scalar {
	return NewUint64Scalar(Uint64Traits.GetValue(value), dataType)
}

func (s Uint64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint64Scalar)
	return ok && s.value == right.value
}

func (s Uint64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint64Scalar) Value() uint64 {
	return s.value
}

func (s Uint64Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Uint64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	Uint64Traits.PutValue(b, s.value)
	return b
}

func (s Uint64Scalar) PutValue(dst []byte) int {
	Uint64Traits.PutValue(dst, s.value)
	return 8
}

func (s Uint64Scalar) ValueSize() int {
	return 8
}

func (s Uint64Scalar) DataType() DataType {
	return s.dataType
}

func (s Uint64Scalar) IsValid() bool {
	return s.isValid
}

type Float16Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float16.Num
}

func NewFloat16ScalarInterface(value interface{}, dataType DataType) Float16Scalar {
	if value == nil {
		return NewFloat16ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case float16.Num:
		return NewFloat16Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewFloat16ScalarInterface unsupported value type: %T", v))
	}
}

func NewFloat16Scalar(value float16.Num, dataType DataType) Float16Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Float16
	}
	return Float16Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFloat16ScalarInvalid(dataType DataType) Float16Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Float16
	}
	return Float16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFloat16ScalarPrimitive(value float16.Num) Float16Scalar {
	return Float16Scalar{
		isValid:  true,
		dataType: FixedWidthTypes.Float16,
		value:    value,
	}
}

func NewFloat16ScalarBytes(value []byte, dataType DataType) Float16Scalar {
	return NewFloat16Scalar(Float16Traits.GetValue(value), dataType)
}

func (s Float16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float16Scalar)
	return ok && s.value == right.value
}

func (s Float16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float16Scalar) Value() float16.Num {
	return s.value
}

func (s Float16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	Float16Traits.PutValue(b, s.value)
	return b
}

func (s Float16Scalar) PutValue(dst []byte) int {
	Float16Traits.PutValue(dst, s.value)
	return 2
}

func (s Float16Scalar) ValueSize() int {
	return 2
}

func (s Float16Scalar) DataType() DataType {
	return s.dataType
}

func (s Float16Scalar) IsValid() bool {
	return s.isValid
}
func (s Float16Scalar) IsNaN() bool {
	return math.IsNaN(float64(s.value.Float32()))
}

type Float32Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float32
}

func NewFloat32ScalarInterface(value interface{}, dataType DataType) Float32Scalar {
	if value == nil {
		return NewFloat32ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case float32:
		return NewFloat32Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewFloat32ScalarInterface unsupported value type: %T", v))
	}
}

func NewFloat32Scalar(value float32, dataType DataType) Float32Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Float32
	}
	return Float32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFloat32ScalarInvalid(dataType DataType) Float32Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Float32
	}
	return Float32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFloat32ScalarPrimitive(value float32) Float32Scalar {
	return Float32Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Float32,
		value:    value,
	}
}

func NewFloat32ScalarBytes(value []byte, dataType DataType) Float32Scalar {
	return NewFloat32Scalar(Float32Traits.GetValue(value), dataType)
}

func (s Float32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float32Scalar)
	return ok && s.value == right.value
}

func (s Float32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float32Scalar) Value() float32 {
	return s.value
}

func (s Float32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	Float32Traits.PutValue(b, s.value)
	return b
}

func (s Float32Scalar) PutValue(dst []byte) int {
	Float32Traits.PutValue(dst, s.value)
	return 4
}

func (s Float32Scalar) ValueSize() int {
	return 4
}

func (s Float32Scalar) DataType() DataType {
	return s.dataType
}

func (s Float32Scalar) IsValid() bool {
	return s.isValid
}
func (s Float32Scalar) IsNaN() bool {
	return math.IsNaN(float64(s.value))
}

type Float64Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float64
}

func NewFloat64ScalarInterface(value interface{}, dataType DataType) Float64Scalar {
	if value == nil {
		return NewFloat64ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case float64:
		return NewFloat64Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewFloat64ScalarInterface unsupported value type: %T", v))
	}
}

func NewFloat64Scalar(value float64, dataType DataType) Float64Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Float64
	}
	return Float64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFloat64ScalarInvalid(dataType DataType) Float64Scalar {
	if dataType == nil {
		dataType = PrimitiveTypes.Float64
	}
	return Float64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFloat64ScalarPrimitive(value float64) Float64Scalar {
	return Float64Scalar{
		isValid:  true,
		dataType: PrimitiveTypes.Float64,
		value:    value,
	}
}

func NewFloat64ScalarBytes(value []byte, dataType DataType) Float64Scalar {
	return NewFloat64Scalar(Float64Traits.GetValue(value), dataType)
}

func (s Float64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float64Scalar)
	return ok && s.value == right.value
}

func (s Float64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float64Scalar) Value() float64 {
	return s.value
}

func (s Float64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	Float64Traits.PutValue(b, s.value)
	return b
}

func (s Float64Scalar) PutValue(dst []byte) int {
	Float64Traits.PutValue(dst, s.value)
	return 8
}

func (s Float64Scalar) ValueSize() int {
	return 8
}

func (s Float64Scalar) DataType() DataType {
	return s.dataType
}

func (s Float64Scalar) IsValid() bool {
	return s.isValid
}
func (s Float64Scalar) IsNaN() bool {
	return math.IsNaN(s.value)
}

type BinaryScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewBinaryScalarInterface(value interface{}, dataType DataType) BinaryScalar {
	if value == nil {
		return NewBinaryScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case []byte:
		return NewBinaryScalarBytes(v, dataType)
	case *memory.Buffer:
		return NewBinaryScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewBinaryScalarInterface unsupported value type: %T", v))
	}
}

func NewBinaryScalar(value *memory.Buffer, dataType DataType) BinaryScalar {
	if dataType == nil {
		dataType = BinaryTypes.Binary
	}
	return BinaryScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewBinaryScalarInvalid(dataType DataType) BinaryScalar {
	if dataType == nil {
		dataType = BinaryTypes.Binary
	}
	return BinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewBinaryScalarBytes(value []byte, dataType DataType) BinaryScalar {
	return NewBinaryScalar(memory.NewBufferBytes(value), dataType)
}

func (s BinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(BinaryScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s BinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s BinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s BinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s BinaryScalar) PutValue(dst []byte) int {
	return copy(dst, s.value.Bytes())
}

func (s BinaryScalar) ValueSize() int {
	panic("not implemented")
}

func (s BinaryScalar) DataType() DataType {
	return s.dataType
}

func (s BinaryScalar) IsValid() bool {
	return s.isValid
}

type StringScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewStringScalarInterface(value interface{}, dataType DataType) StringScalar {
	if value == nil {
		return NewStringScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case string:
		return NewStringScalarBytes([]byte(v), dataType)
	case []byte:
		return NewStringScalarBytes(v, dataType)
	case *memory.Buffer:
		return NewStringScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewStringScalarInterface unsupported value type: %T", v))
	}
}

func NewStringScalar(value *memory.Buffer, dataType DataType) StringScalar {
	if dataType == nil {
		dataType = BinaryTypes.String
	}
	return StringScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewStringScalarInvalid(dataType DataType) StringScalar {
	if dataType == nil {
		dataType = BinaryTypes.String
	}
	return StringScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewStringScalarBytes(value []byte, dataType DataType) StringScalar {
	return NewStringScalar(memory.NewBufferBytes(value), dataType)
}

func (s StringScalar) Equals(other Scalar) bool {
	right, ok := other.(StringScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s StringScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s StringScalar) Value() *memory.Buffer {
	return s.value
}

func (s StringScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s StringScalar) PutValue(dst []byte) int {
	return copy(dst, s.value.Bytes())
}

func (s StringScalar) ValueSize() int {
	panic("not implemented")
}

func (s StringScalar) DataType() DataType {
	return s.dataType
}

func (s StringScalar) IsValid() bool {
	return s.isValid
}

type LargeBinaryScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewLargeBinaryScalarInterface(value interface{}, dataType DataType) LargeBinaryScalar {
	if value == nil {
		return NewLargeBinaryScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case []byte:
		return NewLargeBinaryScalarBytes(v, dataType)
	case *memory.Buffer:
		return NewLargeBinaryScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewLargeBinaryScalarInterface unsupported value type: %T", v))
	}
}

func NewLargeBinaryScalar(value *memory.Buffer, dataType DataType) LargeBinaryScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.LargeBinary
	}
	return LargeBinaryScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewLargeBinaryScalarInvalid(dataType DataType) LargeBinaryScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.LargeBinary
	}
	return LargeBinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewLargeBinaryScalarBytes(value []byte, dataType DataType) LargeBinaryScalar {
	return NewLargeBinaryScalar(memory.NewBufferBytes(value), dataType)
}

func (s LargeBinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(LargeBinaryScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s LargeBinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s LargeBinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s LargeBinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s LargeBinaryScalar) PutValue(dst []byte) int {
	return copy(dst, s.value.Bytes())
}

func (s LargeBinaryScalar) ValueSize() int {
	panic("not implemented")
}

func (s LargeBinaryScalar) DataType() DataType {
	return s.dataType
}

func (s LargeBinaryScalar) IsValid() bool {
	return s.isValid
}

type LargeStringScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewLargeStringScalarInterface(value interface{}, dataType DataType) LargeStringScalar {
	if value == nil {
		return NewLargeStringScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case []byte:
		return NewLargeStringScalarBytes(v, dataType)
	case *memory.Buffer:
		return NewLargeStringScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewLargeStringScalarInterface unsupported value type: %T", v))
	}
}

func NewLargeStringScalar(value *memory.Buffer, dataType DataType) LargeStringScalar {
	return LargeStringScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewLargeStringScalarInvalid(dataType DataType) LargeStringScalar {
	return LargeStringScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewLargeStringScalarBytes(value []byte, dataType DataType) LargeStringScalar {
	return NewLargeStringScalar(memory.NewBufferBytes(value), dataType)
}

func (s LargeStringScalar) Equals(other Scalar) bool {
	right, ok := other.(LargeStringScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s LargeStringScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s LargeStringScalar) Value() *memory.Buffer {
	return s.value
}

func (s LargeStringScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s LargeStringScalar) PutValue(dst []byte) int {
	return copy(dst, s.value.Bytes())
}

func (s LargeStringScalar) ValueSize() int {
	panic("not implemented")
}

func (s LargeStringScalar) DataType() DataType {
	return s.dataType
}

func (s LargeStringScalar) IsValid() bool {
	return s.isValid
}

type FixedSizeBinaryScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewFixedSizeBinaryScalarInterface(value interface{}, dataType DataType) FixedSizeBinaryScalar {
	if value == nil {
		return NewFixedSizeBinaryScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case []byte:
		return NewFixedSizeBinaryScalarBytes(v, dataType)
	case *memory.Buffer:
		return NewFixedSizeBinaryScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewFixedSizeBinaryScalarInterface unsupported value type: %T", v))
	}
}

func NewFixedSizeBinaryScalar(value *memory.Buffer, dataType DataType) FixedSizeBinaryScalar {
	if dataType == nil {
		dataType = (*FixedSizeBinaryType)(nil)
	}
	return FixedSizeBinaryScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFixedSizeBinaryScalarInvalid(dataType DataType) FixedSizeBinaryScalar {
	if dataType == nil {
		dataType = (*FixedSizeBinaryType)(nil)
	}
	return FixedSizeBinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFixedSizeBinaryScalarBytes(value []byte, dataType DataType) FixedSizeBinaryScalar {
	return NewFixedSizeBinaryScalar(memory.NewBufferBytes(value), dataType)
}

func (s FixedSizeBinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(FixedSizeBinaryScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s FixedSizeBinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s FixedSizeBinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s FixedSizeBinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s FixedSizeBinaryScalar) PutValue(dst []byte) int {
	return copy(dst, s.value.Bytes())
}

func (s FixedSizeBinaryScalar) ValueSize() int {
	panic("not implemented")
}

func (s FixedSizeBinaryScalar) DataType() DataType {
	return s.dataType
}

func (s FixedSizeBinaryScalar) IsValid() bool {
	return s.isValid
}

type Date32Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value Date32
}

func NewDate32ScalarInterface(value interface{}, dataType DataType) Date32Scalar {
	if value == nil {
		return NewDate32ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case Date32:
		return NewDate32Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewDate32ScalarInterface unsupported value type: %T", v))
	}
}

func NewDate32Scalar(value Date32, dataType DataType) Date32Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Date32
	}
	return Date32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDate32ScalarInvalid(dataType DataType) Date32Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Date32
	}
	return Date32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDate32ScalarPrimitive(value Date32) Date32Scalar {
	return Date32Scalar{
		isValid:  true,
		dataType: FixedWidthTypes.Date32,
		value:    value,
	}
}

func NewDate32ScalarBytes(value []byte, dataType DataType) Date32Scalar {
	return NewDate32Scalar(Date32Traits.GetValue(value), dataType)
}

func (s Date32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Date32Scalar)
	return ok && s.value == right.value
}

func (s Date32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Date32Scalar) Value() Date32 {
	return s.value
}

func (s Date32Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Date32Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Date32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	Date32Traits.PutValue(b, s.value)
	return b
}

func (s Date32Scalar) PutValue(dst []byte) int {
	Date32Traits.PutValue(dst, s.value)
	return 4
}

func (s Date32Scalar) ValueSize() int {
	return 4
}

func (s Date32Scalar) DataType() DataType {
	return s.dataType
}

func (s Date32Scalar) IsValid() bool {
	return s.isValid
}

type Date64Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value Date64
}

func NewDate64ScalarInterface(value interface{}, dataType DataType) Date64Scalar {
	if value == nil {
		return NewDate64ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case Date64:
		return NewDate64Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewDate64ScalarInterface unsupported value type: %T", v))
	}
}

func NewDate64Scalar(value Date64, dataType DataType) Date64Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Date64
	}
	return Date64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDate64ScalarInvalid(dataType DataType) Date64Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Date64
	}
	return Date64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDate64ScalarPrimitive(value Date64) Date64Scalar {
	return Date64Scalar{
		isValid:  true,
		dataType: FixedWidthTypes.Date64,
		value:    value,
	}
}

func NewDate64ScalarBytes(value []byte, dataType DataType) Date64Scalar {
	return NewDate64Scalar(Date64Traits.GetValue(value), dataType)
}

func (s Date64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Date64Scalar)
	return ok && s.value == right.value
}

func (s Date64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Date64Scalar) Value() Date64 {
	return s.value
}

func (s Date64Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Date64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	Date64Traits.PutValue(b, s.value)
	return b
}

func (s Date64Scalar) PutValue(dst []byte) int {
	Date64Traits.PutValue(dst, s.value)
	return 8
}

func (s Date64Scalar) ValueSize() int {
	return 8
}

func (s Date64Scalar) DataType() DataType {
	return s.dataType
}

func (s Date64Scalar) IsValid() bool {
	return s.isValid
}

type Time32Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value Time32
}

func NewTime32ScalarInterface(value interface{}, dataType DataType) Time32Scalar {
	if value == nil {
		return NewTime32ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case Time32:
		return NewTime32Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewTime32ScalarInterface unsupported value type: %T", v))
	}
}

func NewTime32Scalar(value Time32, dataType DataType) Time32Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Time32ms
	}
	return Time32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewTime32ScalarInvalid(dataType DataType) Time32Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Time32ms
	}
	return Time32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewTime32ScalarPrimitive(value Time32) Time32Scalar {
	return Time32Scalar{
		isValid:  true,
		dataType: FixedWidthTypes.Time32ms,
		value:    value,
	}
}

func NewTime32ScalarBytes(value []byte, dataType DataType) Time32Scalar {
	return NewTime32Scalar(Time32Traits.GetValue(value), dataType)
}

func (s Time32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Time32Scalar)
	return ok && s.value == right.value
}

func (s Time32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Time32Scalar) Value() Time32 {
	return s.value
}

func (s Time32Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Time32Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Time32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	Time32Traits.PutValue(b, s.value)
	return b
}

func (s Time32Scalar) PutValue(dst []byte) int {
	Time32Traits.PutValue(dst, s.value)
	return 4
}

func (s Time32Scalar) ValueSize() int {
	return 4
}

func (s Time32Scalar) DataType() DataType {
	return s.dataType
}

func (s Time32Scalar) IsValid() bool {
	return s.isValid
}

type Time64Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value Time64
}

func NewTime64ScalarInterface(value interface{}, dataType DataType) Time64Scalar {
	if value == nil {
		return NewTime64ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case Time64:
		return NewTime64Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewTime64ScalarInterface unsupported value type: %T", v))
	}
}

func NewTime64Scalar(value Time64, dataType DataType) Time64Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Time64ns
	}
	return Time64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewTime64ScalarInvalid(dataType DataType) Time64Scalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Time64ns
	}
	return Time64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewTime64ScalarPrimitive(value Time64) Time64Scalar {
	return Time64Scalar{
		isValid:  true,
		dataType: FixedWidthTypes.Time64ns,
		value:    value,
	}
}

func NewTime64ScalarBytes(value []byte, dataType DataType) Time64Scalar {
	return NewTime64Scalar(Time64Traits.GetValue(value), dataType)
}

func (s Time64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Time64Scalar)
	return ok && s.value == right.value
}

func (s Time64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Time64Scalar) Value() Time64 {
	return s.value
}

func (s Time64Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Time64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	Time64Traits.PutValue(b, s.value)
	return b
}

func (s Time64Scalar) PutValue(dst []byte) int {
	Time64Traits.PutValue(dst, s.value)
	return 8
}

func (s Time64Scalar) ValueSize() int {
	return 8
}

func (s Time64Scalar) DataType() DataType {
	return s.dataType
}

func (s Time64Scalar) IsValid() bool {
	return s.isValid
}

type TimestampScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value Timestamp
}

func NewTimestampScalarInterface(value interface{}, dataType DataType) TimestampScalar {
	if value == nil {
		return NewTimestampScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case Timestamp:
		return NewTimestampScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewTimestampScalarInterface unsupported value type: %T", v))
	}
}

func NewTimestampScalar(value Timestamp, dataType DataType) TimestampScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Timestamp_ms
	}
	return TimestampScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewTimestampScalarInvalid(dataType DataType) TimestampScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Timestamp_ms
	}
	return TimestampScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewTimestampScalarPrimitive(value Timestamp) TimestampScalar {
	return TimestampScalar{
		isValid:  true,
		dataType: FixedWidthTypes.Timestamp_ms,
		value:    value,
	}
}

func NewTimestampScalarBytes(value []byte, dataType DataType) TimestampScalar {
	return NewTimestampScalar(TimestampTraits.GetValue(value), dataType)
}

func (s TimestampScalar) Equals(other Scalar) bool {
	right, ok := other.(TimestampScalar)
	return ok && s.value == right.value
}

func (s TimestampScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s TimestampScalar) Value() Timestamp {
	return s.value
}

func (s TimestampScalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s TimestampScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	TimestampTraits.PutValue(b, s.value)
	return b
}

func (s TimestampScalar) PutValue(dst []byte) int {
	TimestampTraits.PutValue(dst, s.value)
	return 8
}

func (s TimestampScalar) ValueSize() int {
	return 8
}

func (s TimestampScalar) DataType() DataType {
	return s.dataType
}

func (s TimestampScalar) IsValid() bool {
	return s.isValid
}

type MonthIntervalScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value MonthInterval
}

func NewMonthIntervalScalarInterface(value interface{}, dataType DataType) MonthIntervalScalar {
	if value == nil {
		return NewMonthIntervalScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case MonthInterval:
		return NewMonthIntervalScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewMonthIntervalScalarInterface unsupported value type: %T", v))
	}
}

func NewMonthIntervalScalar(value MonthInterval, dataType DataType) MonthIntervalScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.MonthInterval
	}
	return MonthIntervalScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewMonthIntervalScalarInvalid(dataType DataType) MonthIntervalScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.MonthInterval
	}
	return MonthIntervalScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewMonthIntervalScalarPrimitive(value MonthInterval) MonthIntervalScalar {
	return MonthIntervalScalar{
		isValid:  true,
		dataType: FixedWidthTypes.MonthInterval,
		value:    value,
	}
}

func NewMonthIntervalScalarBytes(value []byte, dataType DataType) MonthIntervalScalar {
	return NewMonthIntervalScalar(MonthIntervalTraits.GetValue(value), dataType)
}

func (s MonthIntervalScalar) Equals(other Scalar) bool {
	right, ok := other.(MonthIntervalScalar)
	return ok && s.value == right.value
}

func (s MonthIntervalScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s MonthIntervalScalar) Value() MonthInterval {
	return s.value
}

func (s MonthIntervalScalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s MonthIntervalScalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s MonthIntervalScalar) ValueBytes() []byte {
	b := make([]byte, 4)
	MonthIntervalTraits.PutValue(b, s.value)
	return b
}

func (s MonthIntervalScalar) PutValue(dst []byte) int {
	MonthIntervalTraits.PutValue(dst, s.value)
	return 4
}

func (s MonthIntervalScalar) ValueSize() int {
	return 4
}

func (s MonthIntervalScalar) DataType() DataType {
	return s.dataType
}

func (s MonthIntervalScalar) IsValid() bool {
	return s.isValid
}

type DayTimeIntervalScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value DayTimeInterval
}

func NewDayTimeIntervalScalarInterface(value interface{}, dataType DataType) DayTimeIntervalScalar {
	if value == nil {
		return NewDayTimeIntervalScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case DayTimeInterval:
		return NewDayTimeIntervalScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewDayTimeIntervalScalarInterface unsupported value type: %T", v))
	}
}

func NewDayTimeIntervalScalar(value DayTimeInterval, dataType DataType) DayTimeIntervalScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.DayTimeInterval
	}
	return DayTimeIntervalScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDayTimeIntervalScalarInvalid(dataType DataType) DayTimeIntervalScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.DayTimeInterval
	}
	return DayTimeIntervalScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDayTimeIntervalScalarPrimitive(value DayTimeInterval) DayTimeIntervalScalar {
	return DayTimeIntervalScalar{
		isValid:  true,
		dataType: FixedWidthTypes.DayTimeInterval,
		value:    value,
	}
}

func NewDayTimeIntervalScalarBytes(value []byte, dataType DataType) DayTimeIntervalScalar {
	return NewDayTimeIntervalScalar(DayTimeIntervalTraits.GetValue(value), dataType)
}

func (s DayTimeIntervalScalar) Equals(other Scalar) bool {
	right, ok := other.(DayTimeIntervalScalar)
	return ok && s.value == right.value
}

func (s DayTimeIntervalScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s DayTimeIntervalScalar) Value() DayTimeInterval {
	return s.value
}

func (s DayTimeIntervalScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	DayTimeIntervalTraits.PutValue(b, s.value)
	return b
}

func (s DayTimeIntervalScalar) PutValue(dst []byte) int {
	DayTimeIntervalTraits.PutValue(dst, s.value)
	return 8
}

func (s DayTimeIntervalScalar) ValueSize() int {
	return 8
}

func (s DayTimeIntervalScalar) DataType() DataType {
	return s.dataType
}

func (s DayTimeIntervalScalar) IsValid() bool {
	return s.isValid
}

type DurationScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value Duration
}

func NewDurationScalarInterface(value interface{}, dataType DataType) DurationScalar {
	if value == nil {
		return NewDurationScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case Duration:
		return NewDurationScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewDurationScalarInterface unsupported value type: %T", v))
	}
}

func NewDurationScalar(value Duration, dataType DataType) DurationScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Duration_ms
	}
	return DurationScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDurationScalarInvalid(dataType DataType) DurationScalar {
	if dataType == nil {
		dataType = FixedWidthTypes.Duration_ms
	}
	return DurationScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDurationScalarPrimitive(value Duration) DurationScalar {
	return DurationScalar{
		isValid:  true,
		dataType: FixedWidthTypes.Duration_ms,
		value:    value,
	}
}

func NewDurationScalarBytes(value []byte, dataType DataType) DurationScalar {
	return NewDurationScalar(DurationTraits.GetValue(value), dataType)
}

func (s DurationScalar) Equals(other Scalar) bool {
	right, ok := other.(DurationScalar)
	return ok && s.value == right.value
}

func (s DurationScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s DurationScalar) Value() Duration {
	return s.value
}

func (s DurationScalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s DurationScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	DurationTraits.PutValue(b, s.value)
	return b
}

func (s DurationScalar) PutValue(dst []byte) int {
	DurationTraits.PutValue(dst, s.value)
	return 8
}

func (s DurationScalar) ValueSize() int {
	return 8
}

func (s DurationScalar) DataType() DataType {
	return s.dataType
}

func (s DurationScalar) IsValid() bool {
	return s.isValid
}

type Decimal128Scalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value decimal128.Num
}

func NewDecimal128ScalarInterface(value interface{}, dataType DataType) Decimal128Scalar {
	if value == nil {
		return NewDecimal128ScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case decimal128.Num:
		return NewDecimal128Scalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewDecimal128ScalarInterface unsupported value type: %T", v))
	}
}

func NewDecimal128Scalar(value decimal128.Num, dataType DataType) Decimal128Scalar {
	if dataType == nil {
		dataType = (*Decimal128Type)(nil)
	}
	return Decimal128Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDecimal128ScalarInvalid(dataType DataType) Decimal128Scalar {
	if dataType == nil {
		dataType = (*Decimal128Type)(nil)
	}
	return Decimal128Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDecimal128ScalarPrimitive(value decimal128.Num) Decimal128Scalar {
	return Decimal128Scalar{
		isValid:  true,
		dataType: (*Decimal128Type)(nil),
		value:    value,
	}
}

func NewDecimal128ScalarBytes(value []byte, dataType DataType) Decimal128Scalar {
	return NewDecimal128Scalar(Decimal128Traits.GetValue(value), dataType)
}

func (s Decimal128Scalar) Equals(other Scalar) bool {
	right, ok := other.(Decimal128Scalar)
	return ok && s.value == right.value
}

func (s Decimal128Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Decimal128Scalar) Value() decimal128.Num {
	return s.value
}

func (s Decimal128Scalar) ValueBytes() []byte {
	b := make([]byte, 16)
	Decimal128Traits.PutValue(b, s.value)
	return b
}

func (s Decimal128Scalar) PutValue(dst []byte) int {
	Decimal128Traits.PutValue(dst, s.value)
	return 16
}

func (s Decimal128Scalar) ValueSize() int {
	return 16
}

func (s Decimal128Scalar) DataType() DataType {
	return s.dataType
}

func (s Decimal128Scalar) IsValid() bool {
	return s.isValid
}

type ListScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value interface{}
}

func NewListScalarInterface(value interface{}, dataType DataType) ListScalar {
	if value == nil {
		return NewListScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case interface{}:
		return NewListScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewListScalarInterface unsupported value type: %T", v))
	}
}

func NewListScalar(value interface{}, dataType DataType) ListScalar {
	if dataType == nil {
		dataType = (*ListType)(nil)
	}
	return ListScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewListScalarInvalid(dataType DataType) ListScalar {
	if dataType == nil {
		dataType = (*ListType)(nil)
	}
	return ListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewListScalarBytes(value []byte, dataType DataType) ListScalar {
	// TODO(nickpoorman): implement
	panic("not implemented")
}

func (s ListScalar) Equals(other Scalar) bool {
	right, ok := other.(ListScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	panic("not implemented")
	// return s.value.Equals(right.value)
}

func (s ListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s ListScalar) Value() interface{} {
	return s.value
}

func (s ListScalar) ValueBytes() []byte {
	panic("not implemented")
}

func (s ListScalar) PutValue(dst []byte) int {
	panic("not implemented")
}

func (s ListScalar) ValueSize() int {
	panic("not implemented")
}

func (s ListScalar) DataType() DataType {
	return s.dataType
}

func (s ListScalar) IsValid() bool {
	return s.isValid
}

type LargeListScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value interface{}
}

func NewLargeListScalarInterface(value interface{}, dataType DataType) LargeListScalar {
	if value == nil {
		return NewLargeListScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case interface{}:
		return NewLargeListScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewLargeListScalarInterface unsupported value type: %T", v))
	}
}

func NewLargeListScalar(value interface{}, dataType DataType) LargeListScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.LargeList
	}
	return LargeListScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewLargeListScalarInvalid(dataType DataType) LargeListScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.LargeList
	}
	return LargeListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewLargeListScalarBytes(value []byte, dataType DataType) LargeListScalar {
	panic("not implemented")
}

func (s LargeListScalar) Equals(other Scalar) bool {
	right, ok := other.(LargeListScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	panic("not implemented")
	// return s.value.Equals(right.value)
}

func (s LargeListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s LargeListScalar) Value() interface{} {
	return s.value
}

func (s LargeListScalar) ValueBytes() []byte {
	panic("not implemented")
}

func (s LargeListScalar) PutValue(dst []byte) int {
	panic("not implemented")
}

func (s LargeListScalar) ValueSize() int {
	panic("not implemented")
}

func (s LargeListScalar) DataType() DataType {
	return s.dataType
}

func (s LargeListScalar) IsValid() bool {
	return s.isValid
}

type MapScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value interface{}
}

func NewMapScalarInterface(value interface{}, dataType DataType) MapScalar {
	if value == nil {
		return NewMapScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case interface{}:
		return NewMapScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewMapScalarInterface unsupported value type: %T", v))
	}
}

func NewMapScalar(value interface{}, dataType DataType) MapScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.Map
	}
	return MapScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewMapScalarInvalid(dataType DataType) MapScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.Map
	}
	return MapScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewMapScalarBytes(value []byte, dataType DataType) MapScalar {
	panic("not implemented")
}

func (s MapScalar) Equals(other Scalar) bool {
	right, ok := other.(MapScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	panic("not implemented")
	// return s.value.Equals(right.value)
}

func (s MapScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s MapScalar) Value() interface{} {
	return s.value
}

func (s MapScalar) ValueBytes() []byte {
	panic("not implemented")
}

func (s MapScalar) PutValue(dst []byte) int {
	panic("not implemented")
}

func (s MapScalar) ValueSize() int {
	panic("not implemented")
}

func (s MapScalar) DataType() DataType {
	return s.dataType
}

func (s MapScalar) IsValid() bool {
	return s.isValid
}

type FixedSizeListScalar struct {
	// The type of the scalar value
	dataType DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value interface{}
}

func NewFixedSizeListScalarInterface(value interface{}, dataType DataType) FixedSizeListScalar {
	if value == nil {
		return NewFixedSizeListScalarInvalid(dataType)
	}

	switch v := value.(type) {
	case interface{}:
		return NewFixedSizeListScalar(v, dataType)
	default:
		panic(fmt.Sprintf("NewFixedSizeListScalarInterface unsupported value type: %T", v))
	}
}

func NewFixedSizeListScalar(value interface{}, dataType DataType) FixedSizeListScalar {
	if dataType == nil {
		dataType = (*FixedSizeListType)(nil)
	}
	return FixedSizeListScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFixedSizeListScalarInvalid(dataType DataType) FixedSizeListScalar {
	if dataType == nil {
		dataType = (*FixedSizeListType)(nil)
	}
	return FixedSizeListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFixedSizeListScalarBytes(value []byte, dataType DataType) FixedSizeListScalar {
	// TODO(nickpoorman): implement
	panic("not implemented")
}

func (s FixedSizeListScalar) Equals(other Scalar) bool {
	right, ok := other.(FixedSizeListScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	panic("not implemented")
	// return s.value.Equals(right.value)
}

func (s FixedSizeListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s FixedSizeListScalar) Value() interface{} {
	return s.value
}

func (s FixedSizeListScalar) ValueBytes() []byte {
	panic("not implemented")
}

func (s FixedSizeListScalar) PutValue(dst []byte) int {
	panic("not implemented")
}

func (s FixedSizeListScalar) ValueSize() int {
	panic("not implemented")
}

func (s FixedSizeListScalar) DataType() DataType {
	return s.dataType
}

func (s FixedSizeListScalar) IsValid() bool {
	return s.isValid
}

func (s *ScalarEqualsVisitor) visitGenerated(left Scalar) bool {
	switch left.(type) {
	case BooleanScalar:
		s.result = left.Equals(s.right)
		return true
	case Int8Scalar:
		s.result = left.Equals(s.right)
		return true
	case Int16Scalar:
		s.result = left.Equals(s.right)
		return true
	case Int32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Int64Scalar:
		s.result = left.Equals(s.right)
		return true
	case Uint8Scalar:
		s.result = left.Equals(s.right)
		return true
	case Uint16Scalar:
		s.result = left.Equals(s.right)
		return true
	case Uint32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Uint64Scalar:
		s.result = left.Equals(s.right)
		return true
	case Float16Scalar:
		s.result = left.Equals(s.right)
		return true
	case Float32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Float64Scalar:
		s.result = left.Equals(s.right)
		return true
	case BinaryScalar:
		s.result = left.Equals(s.right)
		return true
	case StringScalar:
		s.result = left.Equals(s.right)
		return true
	case LargeBinaryScalar:
		s.result = left.Equals(s.right)
		return true
	case LargeStringScalar:
		s.result = left.Equals(s.right)
		return true
	case FixedSizeBinaryScalar:
		s.result = left.Equals(s.right)
		return true
	case Date32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Date64Scalar:
		s.result = left.Equals(s.right)
		return true
	case Time32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Time64Scalar:
		s.result = left.Equals(s.right)
		return true
	case TimestampScalar:
		s.result = left.Equals(s.right)
		return true
	case MonthIntervalScalar:
		s.result = left.Equals(s.right)
		return true
	case DayTimeIntervalScalar:
		s.result = left.Equals(s.right)
		return true
	case DurationScalar:
		s.result = left.Equals(s.right)
		return true
	case Decimal128Scalar:
		s.result = left.Equals(s.right)
		return true
	case ListScalar:
		s.result = left.Equals(s.right)
		return true
	case LargeListScalar:
		s.result = left.Equals(s.right)
		return true
	case MapScalar:
		s.result = left.Equals(s.right)
		return true
	case FixedSizeListScalar:
		s.result = left.Equals(s.right)
		return true
	default:
		return false
	}
}

var (
	_ Scalar = (*BooleanScalar)(nil)
	_ Scalar = (*Int8Scalar)(nil)
	_ Scalar = (*Int16Scalar)(nil)
	_ Scalar = (*Int32Scalar)(nil)
	_ Scalar = (*Int64Scalar)(nil)
	_ Scalar = (*Uint8Scalar)(nil)
	_ Scalar = (*Uint16Scalar)(nil)
	_ Scalar = (*Uint32Scalar)(nil)
	_ Scalar = (*Uint64Scalar)(nil)
	_ Scalar = (*Float16Scalar)(nil)
	_ Scalar = (*Float32Scalar)(nil)
	_ Scalar = (*Float64Scalar)(nil)
	_ Scalar = (*BinaryScalar)(nil)
	_ Scalar = (*StringScalar)(nil)
	_ Scalar = (*LargeBinaryScalar)(nil)
	_ Scalar = (*LargeStringScalar)(nil)
	_ Scalar = (*FixedSizeBinaryScalar)(nil)
	_ Scalar = (*Date32Scalar)(nil)
	_ Scalar = (*Date64Scalar)(nil)
	_ Scalar = (*Time32Scalar)(nil)
	_ Scalar = (*Time64Scalar)(nil)
	_ Scalar = (*TimestampScalar)(nil)
	_ Scalar = (*MonthIntervalScalar)(nil)
	_ Scalar = (*DayTimeIntervalScalar)(nil)
	_ Scalar = (*DurationScalar)(nil)
	_ Scalar = (*Decimal128Scalar)(nil)
	_ Scalar = (*ListScalar)(nil)
	_ Scalar = (*LargeListScalar)(nil)
	_ Scalar = (*MapScalar)(nil)
	_ Scalar = (*FixedSizeListScalar)(nil)
)
