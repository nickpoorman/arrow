package arrow

import (
	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/decimal128"
	"github.com/apache/arrow/go/arrow/float16"
	"github.com/apache/arrow/go/arrow/memory"
)

{{range .In}}
type {{.T}}Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value {{.CType}}
}

func New{{.T}}Scalar(value {{.CType}}, dataType arrow.DataType) {{.T}}Scalar {
	{{- if .DefaultDataType}}
	if dataType == nil {
		dataType = {{.DefaultDataType}}
	}
	{{- end}}
	return {{.T}}Scalar{
		isValid: true,
		dataType: dataType,
		value: value,
	}
}

func New{{.T}}ScalarInvalid(dataType arrow.DataType) {{.T}}Scalar {
	{{- if .DefaultDataType}}
	if dataType == nil {
		dataType = {{.DefaultDataType}}
	}
	{{- end}}
	return {{.T}}Scalar{
		isValid: false,
		dataType: dataType,
	}
}

{{/* TODO(nickpoorman): Implement these */}}
{{- if eq .CType "*memory.Buffer"}}
{{/* panic("dataType cannot be nil") */}}
{{- else if contains .DefaultDataType "UnsupportedTypes"}}
{{/* panic("dataType cannot be nil") */}}
{{- else if eq .T "FixedSizeList"}}
{{/* panic("dataType cannot be nil") */}}
{{- else if eq .T "List"}}
{{/* panic("dataType cannot be nil") */}}
{{- else}}
func New{{.T}}ScalarPrimitive(value {{.CType}}) {{.T}}Scalar {
	return {{.T}}Scalar{
		isValid: true,
		dataType: {{.DefaultDataType}},
		value: value,
	}
}
{{- end}}



func New{{.T}}ScalarBytes(value []byte, dataType arrow.DataType) {{.T}}Scalar {
	{{- if eq .CType "*memory.Buffer"}}
	return New{{.T}}Scalar(memory.NewBufferBytes(value), dataType)
	{{- else if contains .DefaultDataType "UnsupportedTypes"}}
	panic("not implemented")
	{{- else if eq .T "FixedSizeList"}}
	// TODO(nickpoorman): implement
	panic("not implemented")
	{{- else if eq .T "List"}}
	// TODO(nickpoorman): implement
	panic("not implemented")
	{{- else}}
	return New{{.T}}Scalar(arrow.{{.T}}Traits.GetValue(value), dataType)
	{{- end}}
}

func (s {{.T}}Scalar) Equals(other Scalar) bool {
	right, ok := other.({{.T}}Scalar)
	return ok && s.value == right.value
}

func (s {{.T}}Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s {{.T}}Scalar) Value() {{.CType}} {
	return s.value
}

func (s {{.T}}Scalar) ValueBytes() []byte {
	{{- if .SizeBytes}}
	b := make([]byte, {{.SizeBytes}})
	arrow.{{.T}}Traits.PutValue(b, s.value)
	return b
	{{- else if eq .CType "*memory.Buffer"}}
	return s.value.Bytes()
	{{- else}}
	panic("not implemented")
	{{- end}}
}
{{- end}}

var (
	{{range .In}}
	_ Scalar = (*{{.T}}Scalar)(nil)
	{{- end}}
)

{{/* Probably don't want to do this since the types aren't one-to-one */}}
{{/* This would have to be matched off of dataType */}}
{{/* func newScalarGeneratedTypes(value interface{}, dataType arrow.DataType) (Scalar, bool) {
	switch v := value.(type) {
	{{- range .In}}
	case {{.CType}}:
		return New{{.T}}Scalar(v, dataType), true
	{{- end}}
	default:
		return nil, false
	}
} */}}