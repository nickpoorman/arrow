// Code generated by parquet/arrow/scalar.gen.go.tmpl. DO NOT EDIT.

package arrow

import (
	"math"

	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/decimal128"
	"github.com/apache/arrow/go/arrow/float16"
	"github.com/apache/arrow/go/arrow/memory"
)

type BooleanScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value bool
}

func NewBooleanScalar(value bool, dataType arrow.DataType) BooleanScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Boolean
	}
	return BooleanScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewBooleanScalarInvalid(dataType arrow.DataType) BooleanScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Boolean
	}
	return BooleanScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewBooleanScalarPrimitive(value bool) BooleanScalar {
	return BooleanScalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.Boolean,
		value:    value,
	}
}

func NewBooleanScalarBytes(value []byte, dataType arrow.DataType) BooleanScalar {
	return NewBooleanScalar(arrow.BooleanTraits.GetValue(value), dataType)
}

func (s BooleanScalar) Equals(other Scalar) bool {
	right, ok := other.(BooleanScalar)
	return ok && s.value == right.value
}

func (s BooleanScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s BooleanScalar) Value() bool {
	return s.value
}

func (s BooleanScalar) ValueUint32() uint32 {
	if s.value {
		return 1
	} else {
		return 0
	}
}
func (s BooleanScalar) ValueUint64() uint64 {
	if s.value {
		return 1
	} else {
		return 0
	}
}

func (s BooleanScalar) ValueBytes() []byte {
	b := make([]byte, 1)
	arrow.BooleanTraits.PutValue(b, s.value)
	return b
}

func (s BooleanScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s BooleanScalar) IsValid() bool {
	return s.isValid
}

type Int8Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int8
}

func NewInt8Scalar(value int8, dataType arrow.DataType) Int8Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int8
	}
	return Int8Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewInt8ScalarInvalid(dataType arrow.DataType) Int8Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int8
	}
	return Int8Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewInt8ScalarPrimitive(value int8) Int8Scalar {
	return Int8Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Int8,
		value:    value,
	}
}

func NewInt8ScalarBytes(value []byte, dataType arrow.DataType) Int8Scalar {
	return NewInt8Scalar(arrow.Int8Traits.GetValue(value), dataType)
}

func (s Int8Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int8Scalar)
	return ok && s.value == right.value
}

func (s Int8Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int8Scalar) Value() int8 {
	return s.value
}

func (s Int8Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Int8Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Int8Scalar) ValueBytes() []byte {
	b := make([]byte, 1)
	arrow.Int8Traits.PutValue(b, s.value)
	return b
}

func (s Int8Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Int8Scalar) IsValid() bool {
	return s.isValid
}

type Int16Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int16
}

func NewInt16Scalar(value int16, dataType arrow.DataType) Int16Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int16
	}
	return Int16Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewInt16ScalarInvalid(dataType arrow.DataType) Int16Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int16
	}
	return Int16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewInt16ScalarPrimitive(value int16) Int16Scalar {
	return Int16Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Int16,
		value:    value,
	}
}

func NewInt16ScalarBytes(value []byte, dataType arrow.DataType) Int16Scalar {
	return NewInt16Scalar(arrow.Int16Traits.GetValue(value), dataType)
}

func (s Int16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int16Scalar)
	return ok && s.value == right.value
}

func (s Int16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int16Scalar) Value() int16 {
	return s.value
}

func (s Int16Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Int16Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Int16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	arrow.Int16Traits.PutValue(b, s.value)
	return b
}

func (s Int16Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Int16Scalar) IsValid() bool {
	return s.isValid
}

type Int32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int32
}

func NewInt32Scalar(value int32, dataType arrow.DataType) Int32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int32
	}
	return Int32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewInt32ScalarInvalid(dataType arrow.DataType) Int32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int32
	}
	return Int32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewInt32ScalarPrimitive(value int32) Int32Scalar {
	return Int32Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Int32,
		value:    value,
	}
}

func NewInt32ScalarBytes(value []byte, dataType arrow.DataType) Int32Scalar {
	return NewInt32Scalar(arrow.Int32Traits.GetValue(value), dataType)
}

func (s Int32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int32Scalar)
	return ok && s.value == right.value
}

func (s Int32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int32Scalar) Value() int32 {
	return s.value
}

func (s Int32Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Int32Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Int32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Int32Traits.PutValue(b, s.value)
	return b
}

func (s Int32Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Int32Scalar) IsValid() bool {
	return s.isValid
}

type Int64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int64
}

func NewInt64Scalar(value int64, dataType arrow.DataType) Int64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Int64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewInt64ScalarInvalid(dataType arrow.DataType) Int64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Int64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewInt64ScalarPrimitive(value int64) Int64Scalar {
	return Int64Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Int64,
		value:    value,
	}
}

func NewInt64ScalarBytes(value []byte, dataType arrow.DataType) Int64Scalar {
	return NewInt64Scalar(arrow.Int64Traits.GetValue(value), dataType)
}

func (s Int64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int64Scalar)
	return ok && s.value == right.value
}

func (s Int64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int64Scalar) Value() int64 {
	return s.value
}

func (s Int64Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Int64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Int64Traits.PutValue(b, s.value)
	return b
}

func (s Int64Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Int64Scalar) IsValid() bool {
	return s.isValid
}

type Uint8Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint8
}

func NewUint8Scalar(value uint8, dataType arrow.DataType) Uint8Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Uint8
	}
	return Uint8Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewUint8ScalarInvalid(dataType arrow.DataType) Uint8Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Uint8
	}
	return Uint8Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewUint8ScalarPrimitive(value uint8) Uint8Scalar {
	return Uint8Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Uint8,
		value:    value,
	}
}

func NewUint8ScalarBytes(value []byte, dataType arrow.DataType) Uint8Scalar {
	return NewUint8Scalar(arrow.Uint8Traits.GetValue(value), dataType)
}

func (s Uint8Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint8Scalar)
	return ok && s.value == right.value
}

func (s Uint8Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint8Scalar) Value() uint8 {
	return s.value
}

func (s Uint8Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Uint8Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Uint8Scalar) ValueBytes() []byte {
	b := make([]byte, 1)
	arrow.Uint8Traits.PutValue(b, s.value)
	return b
}

func (s Uint8Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Uint8Scalar) IsValid() bool {
	return s.isValid
}

type Uint16Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint16
}

func NewUint16Scalar(value uint16, dataType arrow.DataType) Uint16Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Uint16
	}
	return Uint16Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewUint16ScalarInvalid(dataType arrow.DataType) Uint16Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Uint16
	}
	return Uint16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewUint16ScalarPrimitive(value uint16) Uint16Scalar {
	return Uint16Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Uint16,
		value:    value,
	}
}

func NewUint16ScalarBytes(value []byte, dataType arrow.DataType) Uint16Scalar {
	return NewUint16Scalar(arrow.Uint16Traits.GetValue(value), dataType)
}

func (s Uint16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint16Scalar)
	return ok && s.value == right.value
}

func (s Uint16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint16Scalar) Value() uint16 {
	return s.value
}

func (s Uint16Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Uint16Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Uint16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	arrow.Uint16Traits.PutValue(b, s.value)
	return b
}

func (s Uint16Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Uint16Scalar) IsValid() bool {
	return s.isValid
}

type Uint32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint32
}

func NewUint32Scalar(value uint32, dataType arrow.DataType) Uint32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Uint32
	}
	return Uint32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewUint32ScalarInvalid(dataType arrow.DataType) Uint32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Uint32
	}
	return Uint32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewUint32ScalarPrimitive(value uint32) Uint32Scalar {
	return Uint32Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Uint32,
		value:    value,
	}
}

func NewUint32ScalarBytes(value []byte, dataType arrow.DataType) Uint32Scalar {
	return NewUint32Scalar(arrow.Uint32Traits.GetValue(value), dataType)
}

func (s Uint32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint32Scalar)
	return ok && s.value == right.value
}

func (s Uint32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint32Scalar) Value() uint32 {
	return s.value
}

func (s Uint32Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Uint32Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Uint32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Uint32Traits.PutValue(b, s.value)
	return b
}

func (s Uint32Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Uint32Scalar) IsValid() bool {
	return s.isValid
}

type Uint64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint64
}

func NewUint64Scalar(value uint64, dataType arrow.DataType) Uint64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Uint64
	}
	return Uint64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewUint64ScalarInvalid(dataType arrow.DataType) Uint64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Uint64
	}
	return Uint64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewUint64ScalarPrimitive(value uint64) Uint64Scalar {
	return Uint64Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Uint64,
		value:    value,
	}
}

func NewUint64ScalarBytes(value []byte, dataType arrow.DataType) Uint64Scalar {
	return NewUint64Scalar(arrow.Uint64Traits.GetValue(value), dataType)
}

func (s Uint64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint64Scalar)
	return ok && s.value == right.value
}

func (s Uint64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint64Scalar) Value() uint64 {
	return s.value
}

func (s Uint64Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Uint64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Uint64Traits.PutValue(b, s.value)
	return b
}

func (s Uint64Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Uint64Scalar) IsValid() bool {
	return s.isValid
}

type Float16Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float16.Num
}

func NewFloat16Scalar(value float16.Num, dataType arrow.DataType) Float16Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Float16
	}
	return Float16Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFloat16ScalarInvalid(dataType arrow.DataType) Float16Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Float16
	}
	return Float16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFloat16ScalarPrimitive(value float16.Num) Float16Scalar {
	return Float16Scalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.Float16,
		value:    value,
	}
}

func NewFloat16ScalarBytes(value []byte, dataType arrow.DataType) Float16Scalar {
	return NewFloat16Scalar(arrow.Float16Traits.GetValue(value), dataType)
}

func (s Float16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float16Scalar)
	return ok && s.value == right.value
}

func (s Float16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float16Scalar) Value() float16.Num {
	return s.value
}

func (s Float16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	arrow.Float16Traits.PutValue(b, s.value)
	return b
}

func (s Float16Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Float16Scalar) IsValid() bool {
	return s.isValid
}
func (s Float16Scalar) IsNaN() bool {
	return math.IsNaN(float64(s.value.Float32()))
}

type Float32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float32
}

func NewFloat32Scalar(value float32, dataType arrow.DataType) Float32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Float32
	}
	return Float32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFloat32ScalarInvalid(dataType arrow.DataType) Float32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Float32
	}
	return Float32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFloat32ScalarPrimitive(value float32) Float32Scalar {
	return Float32Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Float32,
		value:    value,
	}
}

func NewFloat32ScalarBytes(value []byte, dataType arrow.DataType) Float32Scalar {
	return NewFloat32Scalar(arrow.Float32Traits.GetValue(value), dataType)
}

func (s Float32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float32Scalar)
	return ok && s.value == right.value
}

func (s Float32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float32Scalar) Value() float32 {
	return s.value
}

func (s Float32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Float32Traits.PutValue(b, s.value)
	return b
}

func (s Float32Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Float32Scalar) IsValid() bool {
	return s.isValid
}
func (s Float32Scalar) IsNaN() bool {
	return math.IsNaN(float64(s.value))
}

type Float64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float64
}

func NewFloat64Scalar(value float64, dataType arrow.DataType) Float64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Float64
	}
	return Float64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFloat64ScalarInvalid(dataType arrow.DataType) Float64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Float64
	}
	return Float64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFloat64ScalarPrimitive(value float64) Float64Scalar {
	return Float64Scalar{
		isValid:  true,
		dataType: arrow.PrimitiveTypes.Float64,
		value:    value,
	}
}

func NewFloat64ScalarBytes(value []byte, dataType arrow.DataType) Float64Scalar {
	return NewFloat64Scalar(arrow.Float64Traits.GetValue(value), dataType)
}

func (s Float64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float64Scalar)
	return ok && s.value == right.value
}

func (s Float64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float64Scalar) Value() float64 {
	return s.value
}

func (s Float64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Float64Traits.PutValue(b, s.value)
	return b
}

func (s Float64Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Float64Scalar) IsValid() bool {
	return s.isValid
}
func (s Float64Scalar) IsNaN() bool {
	return math.IsNaN(s.value)
}

type BinaryScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewBinaryScalar(value *memory.Buffer, dataType arrow.DataType) BinaryScalar {
	if dataType == nil {
		dataType = arrow.BinaryTypes.Binary
	}
	return BinaryScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewBinaryScalarInvalid(dataType arrow.DataType) BinaryScalar {
	if dataType == nil {
		dataType = arrow.BinaryTypes.Binary
	}
	return BinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewBinaryScalarBytes(value []byte, dataType arrow.DataType) BinaryScalar {
	return NewBinaryScalar(memory.NewBufferBytes(value), dataType)
}

func (s BinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(BinaryScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s BinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s BinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s BinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s BinaryScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s BinaryScalar) IsValid() bool {
	return s.isValid
}

type StringScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewStringScalar(value *memory.Buffer, dataType arrow.DataType) StringScalar {
	if dataType == nil {
		dataType = arrow.BinaryTypes.String
	}
	return StringScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewStringScalarInvalid(dataType arrow.DataType) StringScalar {
	if dataType == nil {
		dataType = arrow.BinaryTypes.String
	}
	return StringScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewStringScalarBytes(value []byte, dataType arrow.DataType) StringScalar {
	return NewStringScalar(memory.NewBufferBytes(value), dataType)
}

func (s StringScalar) Equals(other Scalar) bool {
	right, ok := other.(StringScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s StringScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s StringScalar) Value() *memory.Buffer {
	return s.value
}

func (s StringScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s StringScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s StringScalar) IsValid() bool {
	return s.isValid
}

type LargeBinaryScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewLargeBinaryScalar(value *memory.Buffer, dataType arrow.DataType) LargeBinaryScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.LargeBinary
	}
	return LargeBinaryScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewLargeBinaryScalarInvalid(dataType arrow.DataType) LargeBinaryScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.LargeBinary
	}
	return LargeBinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewLargeBinaryScalarBytes(value []byte, dataType arrow.DataType) LargeBinaryScalar {
	return NewLargeBinaryScalar(memory.NewBufferBytes(value), dataType)
}

func (s LargeBinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(LargeBinaryScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s LargeBinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s LargeBinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s LargeBinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s LargeBinaryScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s LargeBinaryScalar) IsValid() bool {
	return s.isValid
}

type LargeStringScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewLargeStringScalar(value *memory.Buffer, dataType arrow.DataType) LargeStringScalar {
	return LargeStringScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewLargeStringScalarInvalid(dataType arrow.DataType) LargeStringScalar {
	return LargeStringScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewLargeStringScalarBytes(value []byte, dataType arrow.DataType) LargeStringScalar {
	return NewLargeStringScalar(memory.NewBufferBytes(value), dataType)
}

func (s LargeStringScalar) Equals(other Scalar) bool {
	right, ok := other.(LargeStringScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s LargeStringScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s LargeStringScalar) Value() *memory.Buffer {
	return s.value
}

func (s LargeStringScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s LargeStringScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s LargeStringScalar) IsValid() bool {
	return s.isValid
}

type FixedSizeBinaryScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewFixedSizeBinaryScalar(value *memory.Buffer, dataType arrow.DataType) FixedSizeBinaryScalar {
	if dataType == nil {
		dataType = (*arrow.FixedSizeBinaryType)(nil)
	}
	return FixedSizeBinaryScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFixedSizeBinaryScalarInvalid(dataType arrow.DataType) FixedSizeBinaryScalar {
	if dataType == nil {
		dataType = (*arrow.FixedSizeBinaryType)(nil)
	}
	return FixedSizeBinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFixedSizeBinaryScalarBytes(value []byte, dataType arrow.DataType) FixedSizeBinaryScalar {
	return NewFixedSizeBinaryScalar(memory.NewBufferBytes(value), dataType)
}

func (s FixedSizeBinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(FixedSizeBinaryScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	return s.value.Equals(right.value)
}

func (s FixedSizeBinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s FixedSizeBinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s FixedSizeBinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

func (s FixedSizeBinaryScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s FixedSizeBinaryScalar) IsValid() bool {
	return s.isValid
}

type Date32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Date32
}

func NewDate32Scalar(value arrow.Date32, dataType arrow.DataType) Date32Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Date32
	}
	return Date32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDate32ScalarInvalid(dataType arrow.DataType) Date32Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Date32
	}
	return Date32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDate32ScalarPrimitive(value arrow.Date32) Date32Scalar {
	return Date32Scalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.Date32,
		value:    value,
	}
}

func NewDate32ScalarBytes(value []byte, dataType arrow.DataType) Date32Scalar {
	return NewDate32Scalar(arrow.Date32Traits.GetValue(value), dataType)
}

func (s Date32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Date32Scalar)
	return ok && s.value == right.value
}

func (s Date32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Date32Scalar) Value() arrow.Date32 {
	return s.value
}

func (s Date32Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Date32Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Date32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Date32Traits.PutValue(b, s.value)
	return b
}

func (s Date32Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Date32Scalar) IsValid() bool {
	return s.isValid
}

type Date64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Date64
}

func NewDate64Scalar(value arrow.Date64, dataType arrow.DataType) Date64Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Date64
	}
	return Date64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDate64ScalarInvalid(dataType arrow.DataType) Date64Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Date64
	}
	return Date64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDate64ScalarPrimitive(value arrow.Date64) Date64Scalar {
	return Date64Scalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.Date64,
		value:    value,
	}
}

func NewDate64ScalarBytes(value []byte, dataType arrow.DataType) Date64Scalar {
	return NewDate64Scalar(arrow.Date64Traits.GetValue(value), dataType)
}

func (s Date64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Date64Scalar)
	return ok && s.value == right.value
}

func (s Date64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Date64Scalar) Value() arrow.Date64 {
	return s.value
}

func (s Date64Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Date64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Date64Traits.PutValue(b, s.value)
	return b
}

func (s Date64Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Date64Scalar) IsValid() bool {
	return s.isValid
}

type Time32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Time32
}

func NewTime32Scalar(value arrow.Time32, dataType arrow.DataType) Time32Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Time32ms
	}
	return Time32Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewTime32ScalarInvalid(dataType arrow.DataType) Time32Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Time32ms
	}
	return Time32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewTime32ScalarPrimitive(value arrow.Time32) Time32Scalar {
	return Time32Scalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.Time32ms,
		value:    value,
	}
}

func NewTime32ScalarBytes(value []byte, dataType arrow.DataType) Time32Scalar {
	return NewTime32Scalar(arrow.Time32Traits.GetValue(value), dataType)
}

func (s Time32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Time32Scalar)
	return ok && s.value == right.value
}

func (s Time32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Time32Scalar) Value() arrow.Time32 {
	return s.value
}

func (s Time32Scalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s Time32Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Time32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Time32Traits.PutValue(b, s.value)
	return b
}

func (s Time32Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Time32Scalar) IsValid() bool {
	return s.isValid
}

type Time64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Time64
}

func NewTime64Scalar(value arrow.Time64, dataType arrow.DataType) Time64Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Time64ns
	}
	return Time64Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewTime64ScalarInvalid(dataType arrow.DataType) Time64Scalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Time64ns
	}
	return Time64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewTime64ScalarPrimitive(value arrow.Time64) Time64Scalar {
	return Time64Scalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.Time64ns,
		value:    value,
	}
}

func NewTime64ScalarBytes(value []byte, dataType arrow.DataType) Time64Scalar {
	return NewTime64Scalar(arrow.Time64Traits.GetValue(value), dataType)
}

func (s Time64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Time64Scalar)
	return ok && s.value == right.value
}

func (s Time64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Time64Scalar) Value() arrow.Time64 {
	return s.value
}

func (s Time64Scalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s Time64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Time64Traits.PutValue(b, s.value)
	return b
}

func (s Time64Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Time64Scalar) IsValid() bool {
	return s.isValid
}

type TimestampScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Timestamp
}

func NewTimestampScalar(value arrow.Timestamp, dataType arrow.DataType) TimestampScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Timestamp_ms
	}
	return TimestampScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewTimestampScalarInvalid(dataType arrow.DataType) TimestampScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Timestamp_ms
	}
	return TimestampScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewTimestampScalarPrimitive(value arrow.Timestamp) TimestampScalar {
	return TimestampScalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.Timestamp_ms,
		value:    value,
	}
}

func NewTimestampScalarBytes(value []byte, dataType arrow.DataType) TimestampScalar {
	return NewTimestampScalar(arrow.TimestampTraits.GetValue(value), dataType)
}

func (s TimestampScalar) Equals(other Scalar) bool {
	right, ok := other.(TimestampScalar)
	return ok && s.value == right.value
}

func (s TimestampScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s TimestampScalar) Value() arrow.Timestamp {
	return s.value
}

func (s TimestampScalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s TimestampScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.TimestampTraits.PutValue(b, s.value)
	return b
}

func (s TimestampScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s TimestampScalar) IsValid() bool {
	return s.isValid
}

type MonthIntervalScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.MonthInterval
}

func NewMonthIntervalScalar(value arrow.MonthInterval, dataType arrow.DataType) MonthIntervalScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.MonthInterval
	}
	return MonthIntervalScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewMonthIntervalScalarInvalid(dataType arrow.DataType) MonthIntervalScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.MonthInterval
	}
	return MonthIntervalScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewMonthIntervalScalarPrimitive(value arrow.MonthInterval) MonthIntervalScalar {
	return MonthIntervalScalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.MonthInterval,
		value:    value,
	}
}

func NewMonthIntervalScalarBytes(value []byte, dataType arrow.DataType) MonthIntervalScalar {
	return NewMonthIntervalScalar(arrow.MonthIntervalTraits.GetValue(value), dataType)
}

func (s MonthIntervalScalar) Equals(other Scalar) bool {
	right, ok := other.(MonthIntervalScalar)
	return ok && s.value == right.value
}

func (s MonthIntervalScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s MonthIntervalScalar) Value() arrow.MonthInterval {
	return s.value
}

func (s MonthIntervalScalar) ValueUint32() uint32 {
	return uint32(s.value)
}
func (s MonthIntervalScalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s MonthIntervalScalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.MonthIntervalTraits.PutValue(b, s.value)
	return b
}

func (s MonthIntervalScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s MonthIntervalScalar) IsValid() bool {
	return s.isValid
}

type DayTimeIntervalScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.DayTimeInterval
}

func NewDayTimeIntervalScalar(value arrow.DayTimeInterval, dataType arrow.DataType) DayTimeIntervalScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.DayTimeInterval
	}
	return DayTimeIntervalScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDayTimeIntervalScalarInvalid(dataType arrow.DataType) DayTimeIntervalScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.DayTimeInterval
	}
	return DayTimeIntervalScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDayTimeIntervalScalarPrimitive(value arrow.DayTimeInterval) DayTimeIntervalScalar {
	return DayTimeIntervalScalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.DayTimeInterval,
		value:    value,
	}
}

func NewDayTimeIntervalScalarBytes(value []byte, dataType arrow.DataType) DayTimeIntervalScalar {
	return NewDayTimeIntervalScalar(arrow.DayTimeIntervalTraits.GetValue(value), dataType)
}

func (s DayTimeIntervalScalar) Equals(other Scalar) bool {
	right, ok := other.(DayTimeIntervalScalar)
	return ok && s.value == right.value
}

func (s DayTimeIntervalScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s DayTimeIntervalScalar) Value() arrow.DayTimeInterval {
	return s.value
}

func (s DayTimeIntervalScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.DayTimeIntervalTraits.PutValue(b, s.value)
	return b
}

func (s DayTimeIntervalScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s DayTimeIntervalScalar) IsValid() bool {
	return s.isValid
}

type DurationScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Duration
}

func NewDurationScalar(value arrow.Duration, dataType arrow.DataType) DurationScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Duration_ms
	}
	return DurationScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDurationScalarInvalid(dataType arrow.DataType) DurationScalar {
	if dataType == nil {
		dataType = arrow.FixedWidthTypes.Duration_ms
	}
	return DurationScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDurationScalarPrimitive(value arrow.Duration) DurationScalar {
	return DurationScalar{
		isValid:  true,
		dataType: arrow.FixedWidthTypes.Duration_ms,
		value:    value,
	}
}

func NewDurationScalarBytes(value []byte, dataType arrow.DataType) DurationScalar {
	return NewDurationScalar(arrow.DurationTraits.GetValue(value), dataType)
}

func (s DurationScalar) Equals(other Scalar) bool {
	right, ok := other.(DurationScalar)
	return ok && s.value == right.value
}

func (s DurationScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s DurationScalar) Value() arrow.Duration {
	return s.value
}

func (s DurationScalar) ValueUint64() uint64 {
	return uint64(s.value)
}

func (s DurationScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.DurationTraits.PutValue(b, s.value)
	return b
}

func (s DurationScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s DurationScalar) IsValid() bool {
	return s.isValid
}

type Decimal128Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value decimal128.Num
}

func NewDecimal128Scalar(value decimal128.Num, dataType arrow.DataType) Decimal128Scalar {
	if dataType == nil {
		dataType = (*arrow.Decimal128Type)(nil)
	}
	return Decimal128Scalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewDecimal128ScalarInvalid(dataType arrow.DataType) Decimal128Scalar {
	if dataType == nil {
		dataType = (*arrow.Decimal128Type)(nil)
	}
	return Decimal128Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewDecimal128ScalarPrimitive(value decimal128.Num) Decimal128Scalar {
	return Decimal128Scalar{
		isValid:  true,
		dataType: (*arrow.Decimal128Type)(nil),
		value:    value,
	}
}

func NewDecimal128ScalarBytes(value []byte, dataType arrow.DataType) Decimal128Scalar {
	return NewDecimal128Scalar(arrow.Decimal128Traits.GetValue(value), dataType)
}

func (s Decimal128Scalar) Equals(other Scalar) bool {
	right, ok := other.(Decimal128Scalar)
	return ok && s.value == right.value
}

func (s Decimal128Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Decimal128Scalar) Value() decimal128.Num {
	return s.value
}

func (s Decimal128Scalar) ValueBytes() []byte {
	b := make([]byte, 16)
	arrow.Decimal128Traits.PutValue(b, s.value)
	return b
}

func (s Decimal128Scalar) DataType() arrow.DataType {
	return s.dataType
}

func (s Decimal128Scalar) IsValid() bool {
	return s.isValid
}

type ListScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value array.Interface
}

func NewListScalar(value array.Interface, dataType arrow.DataType) ListScalar {
	if dataType == nil {
		dataType = (*arrow.ListType)(nil)
	}
	return ListScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewListScalarInvalid(dataType arrow.DataType) ListScalar {
	if dataType == nil {
		dataType = (*arrow.ListType)(nil)
	}
	return ListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewListScalarBytes(value []byte, dataType arrow.DataType) ListScalar {
	// TODO(nickpoorman): implement
	panic("not implemented")
}

func (s ListScalar) Equals(other Scalar) bool {
	right, ok := other.(ListScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	// TODO(nickpoorman): array.Interface needs an Equals method
	panic("not implemented")
	// return s.value.Equals(right.value)
}

func (s ListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s ListScalar) Value() array.Interface {
	return s.value
}

func (s ListScalar) ValueBytes() []byte {
	panic("not implemented")
}

func (s ListScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s ListScalar) IsValid() bool {
	return s.isValid
}

type LargeListScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value array.Interface
}

func NewLargeListScalar(value array.Interface, dataType arrow.DataType) LargeListScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.LargeList
	}
	return LargeListScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewLargeListScalarInvalid(dataType arrow.DataType) LargeListScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.LargeList
	}
	return LargeListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewLargeListScalarBytes(value []byte, dataType arrow.DataType) LargeListScalar {
	panic("not implemented")
}

func (s LargeListScalar) Equals(other Scalar) bool {
	right, ok := other.(LargeListScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	// TODO(nickpoorman): array.Interface needs an Equals method
	panic("not implemented")
	// return s.value.Equals(right.value)
}

func (s LargeListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s LargeListScalar) Value() array.Interface {
	return s.value
}

func (s LargeListScalar) ValueBytes() []byte {
	panic("not implemented")
}

func (s LargeListScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s LargeListScalar) IsValid() bool {
	return s.isValid
}

type MapScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value array.Interface
}

func NewMapScalar(value array.Interface, dataType arrow.DataType) MapScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.Map
	}
	return MapScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewMapScalarInvalid(dataType arrow.DataType) MapScalar {
	if dataType == nil {
		dataType = UnsupportedTypes.Map
	}
	return MapScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewMapScalarBytes(value []byte, dataType arrow.DataType) MapScalar {
	panic("not implemented")
}

func (s MapScalar) Equals(other Scalar) bool {
	right, ok := other.(MapScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	// TODO(nickpoorman): array.Interface needs an Equals method
	panic("not implemented")
	// return s.value.Equals(right.value)
}

func (s MapScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s MapScalar) Value() array.Interface {
	return s.value
}

func (s MapScalar) ValueBytes() []byte {
	panic("not implemented")
}

func (s MapScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s MapScalar) IsValid() bool {
	return s.isValid
}

type FixedSizeListScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value array.Interface
}

func NewFixedSizeListScalar(value array.Interface, dataType arrow.DataType) FixedSizeListScalar {
	if dataType == nil {
		dataType = (*arrow.FixedSizeListType)(nil)
	}
	return FixedSizeListScalar{
		isValid:  true,
		dataType: dataType,
		value:    value,
	}
}

func NewFixedSizeListScalarInvalid(dataType arrow.DataType) FixedSizeListScalar {
	if dataType == nil {
		dataType = (*arrow.FixedSizeListType)(nil)
	}
	return FixedSizeListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func NewFixedSizeListScalarBytes(value []byte, dataType arrow.DataType) FixedSizeListScalar {
	// TODO(nickpoorman): implement
	panic("not implemented")
}

func (s FixedSizeListScalar) Equals(other Scalar) bool {
	right, ok := other.(FixedSizeListScalar)
	if !ok {
		return false
	}
	if s.value == nil && right.value == nil {
		return true
	}
	if s.value == nil || right.value == nil {
		return false
	}
	// TODO(nickpoorman): array.Interface needs an Equals method
	panic("not implemented")
	// return s.value.Equals(right.value)
}

func (s FixedSizeListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s FixedSizeListScalar) Value() array.Interface {
	return s.value
}

func (s FixedSizeListScalar) ValueBytes() []byte {
	panic("not implemented")
}

func (s FixedSizeListScalar) DataType() arrow.DataType {
	return s.dataType
}

func (s FixedSizeListScalar) IsValid() bool {
	return s.isValid
}

func (s *ScalarEqualsVisitor) visitGenerated(left Scalar) bool {
	switch left.(type) {
	case BooleanScalar:
		s.result = left.Equals(s.right)
		return true
	case Int8Scalar:
		s.result = left.Equals(s.right)
		return true
	case Int16Scalar:
		s.result = left.Equals(s.right)
		return true
	case Int32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Int64Scalar:
		s.result = left.Equals(s.right)
		return true
	case Uint8Scalar:
		s.result = left.Equals(s.right)
		return true
	case Uint16Scalar:
		s.result = left.Equals(s.right)
		return true
	case Uint32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Uint64Scalar:
		s.result = left.Equals(s.right)
		return true
	case Float16Scalar:
		s.result = left.Equals(s.right)
		return true
	case Float32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Float64Scalar:
		s.result = left.Equals(s.right)
		return true
	case BinaryScalar:
		s.result = left.Equals(s.right)
		return true
	case StringScalar:
		s.result = left.Equals(s.right)
		return true
	case LargeBinaryScalar:
		s.result = left.Equals(s.right)
		return true
	case LargeStringScalar:
		s.result = left.Equals(s.right)
		return true
	case FixedSizeBinaryScalar:
		s.result = left.Equals(s.right)
		return true
	case Date32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Date64Scalar:
		s.result = left.Equals(s.right)
		return true
	case Time32Scalar:
		s.result = left.Equals(s.right)
		return true
	case Time64Scalar:
		s.result = left.Equals(s.right)
		return true
	case TimestampScalar:
		s.result = left.Equals(s.right)
		return true
	case MonthIntervalScalar:
		s.result = left.Equals(s.right)
		return true
	case DayTimeIntervalScalar:
		s.result = left.Equals(s.right)
		return true
	case DurationScalar:
		s.result = left.Equals(s.right)
		return true
	case Decimal128Scalar:
		s.result = left.Equals(s.right)
		return true
	case ListScalar:
		s.result = left.Equals(s.right)
		return true
	case LargeListScalar:
		s.result = left.Equals(s.right)
		return true
	case MapScalar:
		s.result = left.Equals(s.right)
		return true
	case FixedSizeListScalar:
		s.result = left.Equals(s.right)
		return true
	default:
		return false
	}
}

var (
	_ Scalar = (*BooleanScalar)(nil)
	_ Scalar = (*Int8Scalar)(nil)
	_ Scalar = (*Int16Scalar)(nil)
	_ Scalar = (*Int32Scalar)(nil)
	_ Scalar = (*Int64Scalar)(nil)
	_ Scalar = (*Uint8Scalar)(nil)
	_ Scalar = (*Uint16Scalar)(nil)
	_ Scalar = (*Uint32Scalar)(nil)
	_ Scalar = (*Uint64Scalar)(nil)
	_ Scalar = (*Float16Scalar)(nil)
	_ Scalar = (*Float32Scalar)(nil)
	_ Scalar = (*Float64Scalar)(nil)
	_ Scalar = (*BinaryScalar)(nil)
	_ Scalar = (*StringScalar)(nil)
	_ Scalar = (*LargeBinaryScalar)(nil)
	_ Scalar = (*LargeStringScalar)(nil)
	_ Scalar = (*FixedSizeBinaryScalar)(nil)
	_ Scalar = (*Date32Scalar)(nil)
	_ Scalar = (*Date64Scalar)(nil)
	_ Scalar = (*Time32Scalar)(nil)
	_ Scalar = (*Time64Scalar)(nil)
	_ Scalar = (*TimestampScalar)(nil)
	_ Scalar = (*MonthIntervalScalar)(nil)
	_ Scalar = (*DayTimeIntervalScalar)(nil)
	_ Scalar = (*DurationScalar)(nil)
	_ Scalar = (*Decimal128Scalar)(nil)
	_ Scalar = (*ListScalar)(nil)
	_ Scalar = (*LargeListScalar)(nil)
	_ Scalar = (*MapScalar)(nil)
	_ Scalar = (*FixedSizeListScalar)(nil)
)
