// Code generated by parquet/arrow/scalar.gen.go.tmpl. DO NOT EDIT.

package arrow

import (
	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/decimal128"
	"github.com/apache/arrow/go/arrow/float16"
	"github.com/apache/arrow/go/arrow/memory"
)

type BooleanScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value bool
}

func NewBooleanScalar(value bool, dataType arrow.DataType) BooleanScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return BooleanScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s BooleanScalar) Equals(other Scalar) bool {
	right, ok := other.(BooleanScalar)
	return ok && s.value == right.value
}

func (s BooleanScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s BooleanScalar) Value() bool {
	return s.value
}

func (s BooleanScalar) ValueBytes() []byte {
	b := make([]byte, 1)
	arrow.BooleanTraits.PutValue(b, s.value)
	return b
}

type Int8Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int8
}

func NewInt8Scalar(value int8, dataType arrow.DataType) Int8Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Int8Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Int8Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int8Scalar)
	return ok && s.value == right.value
}

func (s Int8Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int8Scalar) Value() int8 {
	return s.value
}

func (s Int8Scalar) ValueBytes() []byte {
	b := make([]byte, 1)
	arrow.Int8Traits.PutValue(b, s.value)
	return b
}

type Int16Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int16
}

func NewInt16Scalar(value int16, dataType arrow.DataType) Int16Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Int16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Int16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int16Scalar)
	return ok && s.value == right.value
}

func (s Int16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int16Scalar) Value() int16 {
	return s.value
}

func (s Int16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	arrow.Int16Traits.PutValue(b, s.value)
	return b
}

type Int32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int32
}

func NewInt32Scalar(value int32, dataType arrow.DataType) Int32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Int32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Int32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int32Scalar)
	return ok && s.value == right.value
}

func (s Int32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int32Scalar) Value() int32 {
	return s.value
}

func (s Int32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Int32Traits.PutValue(b, s.value)
	return b
}

type Int64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value int64
}

func NewInt64Scalar(value int64, dataType arrow.DataType) Int64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Int64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Int64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Int64Scalar)
	return ok && s.value == right.value
}

func (s Int64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Int64Scalar) Value() int64 {
	return s.value
}

func (s Int64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Int64Traits.PutValue(b, s.value)
	return b
}

type Uint8Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint8
}

func NewUint8Scalar(value uint8, dataType arrow.DataType) Uint8Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Uint8Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Uint8Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint8Scalar)
	return ok && s.value == right.value
}

func (s Uint8Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint8Scalar) Value() uint8 {
	return s.value
}

func (s Uint8Scalar) ValueBytes() []byte {
	b := make([]byte, 1)
	arrow.Uint8Traits.PutValue(b, s.value)
	return b
}

type Uint16Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint16
}

func NewUint16Scalar(value uint16, dataType arrow.DataType) Uint16Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Uint16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Uint16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint16Scalar)
	return ok && s.value == right.value
}

func (s Uint16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint16Scalar) Value() uint16 {
	return s.value
}

func (s Uint16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	arrow.Uint16Traits.PutValue(b, s.value)
	return b
}

type Uint32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint32
}

func NewUint32Scalar(value uint32, dataType arrow.DataType) Uint32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Uint32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Uint32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint32Scalar)
	return ok && s.value == right.value
}

func (s Uint32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint32Scalar) Value() uint32 {
	return s.value
}

func (s Uint32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Uint32Traits.PutValue(b, s.value)
	return b
}

type Uint64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value uint64
}

func NewUint64Scalar(value uint64, dataType arrow.DataType) Uint64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Uint64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Uint64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Uint64Scalar)
	return ok && s.value == right.value
}

func (s Uint64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Uint64Scalar) Value() uint64 {
	return s.value
}

func (s Uint64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Uint64Traits.PutValue(b, s.value)
	return b
}

type Float16Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float16.Num
}

func NewFloat16Scalar(value float16.Num, dataType arrow.DataType) Float16Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Float16Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Float16Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float16Scalar)
	return ok && s.value == right.value
}

func (s Float16Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float16Scalar) Value() float16.Num {
	return s.value
}

func (s Float16Scalar) ValueBytes() []byte {
	b := make([]byte, 2)
	arrow.Float16Traits.PutValue(b, s.value)
	return b
}

type Float32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float32
}

func NewFloat32Scalar(value float32, dataType arrow.DataType) Float32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Float32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Float32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float32Scalar)
	return ok && s.value == right.value
}

func (s Float32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float32Scalar) Value() float32 {
	return s.value
}

func (s Float32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Float32Traits.PutValue(b, s.value)
	return b
}

type Float64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value float64
}

func NewFloat64Scalar(value float64, dataType arrow.DataType) Float64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Float64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Float64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Float64Scalar)
	return ok && s.value == right.value
}

func (s Float64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Float64Scalar) Value() float64 {
	return s.value
}

func (s Float64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Float64Traits.PutValue(b, s.value)
	return b
}

type BinaryScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewBinaryScalar(value *memory.Buffer, dataType arrow.DataType) BinaryScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return BinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s BinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(BinaryScalar)
	return ok && s.value == right.value
}

func (s BinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s BinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s BinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

type StringScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewStringScalar(value *memory.Buffer, dataType arrow.DataType) StringScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return StringScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s StringScalar) Equals(other Scalar) bool {
	right, ok := other.(StringScalar)
	return ok && s.value == right.value
}

func (s StringScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s StringScalar) Value() *memory.Buffer {
	return s.value
}

func (s StringScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

type LargeBinaryScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewLargeBinaryScalar(value *memory.Buffer, dataType arrow.DataType) LargeBinaryScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return LargeBinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s LargeBinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(LargeBinaryScalar)
	return ok && s.value == right.value
}

func (s LargeBinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s LargeBinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s LargeBinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

type LargeStringScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewLargeStringScalar(value *memory.Buffer, dataType arrow.DataType) LargeStringScalar {
	return LargeStringScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s LargeStringScalar) Equals(other Scalar) bool {
	right, ok := other.(LargeStringScalar)
	return ok && s.value == right.value
}

func (s LargeStringScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s LargeStringScalar) Value() *memory.Buffer {
	return s.value
}

func (s LargeStringScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

type FixedSizeBinaryScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value *memory.Buffer
}

func NewFixedSizeBinaryScalar(value *memory.Buffer, dataType arrow.DataType) FixedSizeBinaryScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return FixedSizeBinaryScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s FixedSizeBinaryScalar) Equals(other Scalar) bool {
	right, ok := other.(FixedSizeBinaryScalar)
	return ok && s.value == right.value
}

func (s FixedSizeBinaryScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s FixedSizeBinaryScalar) Value() *memory.Buffer {
	return s.value
}

func (s FixedSizeBinaryScalar) ValueBytes() []byte {
	return s.value.Bytes()
}

type Date32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Date32
}

func NewDate32Scalar(value arrow.Date32, dataType arrow.DataType) Date32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Date32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Date32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Date32Scalar)
	return ok && s.value == right.value
}

func (s Date32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Date32Scalar) Value() arrow.Date32 {
	return s.value
}

func (s Date32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Date32Traits.PutValue(b, s.value)
	return b
}

type Date64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Date64
}

func NewDate64Scalar(value arrow.Date64, dataType arrow.DataType) Date64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Date64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Date64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Date64Scalar)
	return ok && s.value == right.value
}

func (s Date64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Date64Scalar) Value() arrow.Date64 {
	return s.value
}

func (s Date64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Date64Traits.PutValue(b, s.value)
	return b
}

type Time32Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Time32
}

func NewTime32Scalar(value arrow.Time32, dataType arrow.DataType) Time32Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Time32Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Time32Scalar) Equals(other Scalar) bool {
	right, ok := other.(Time32Scalar)
	return ok && s.value == right.value
}

func (s Time32Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Time32Scalar) Value() arrow.Time32 {
	return s.value
}

func (s Time32Scalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.Time32Traits.PutValue(b, s.value)
	return b
}

type Time64Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Time64
}

func NewTime64Scalar(value arrow.Time64, dataType arrow.DataType) Time64Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Time64Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Time64Scalar) Equals(other Scalar) bool {
	right, ok := other.(Time64Scalar)
	return ok && s.value == right.value
}

func (s Time64Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Time64Scalar) Value() arrow.Time64 {
	return s.value
}

func (s Time64Scalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.Time64Traits.PutValue(b, s.value)
	return b
}

type TimestampScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Timestamp
}

func NewTimestampScalar(value arrow.Timestamp, dataType arrow.DataType) TimestampScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return TimestampScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s TimestampScalar) Equals(other Scalar) bool {
	right, ok := other.(TimestampScalar)
	return ok && s.value == right.value
}

func (s TimestampScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s TimestampScalar) Value() arrow.Timestamp {
	return s.value
}

func (s TimestampScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.TimestampTraits.PutValue(b, s.value)
	return b
}

type MonthIntervalScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.MonthInterval
}

func NewMonthIntervalScalar(value arrow.MonthInterval, dataType arrow.DataType) MonthIntervalScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return MonthIntervalScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s MonthIntervalScalar) Equals(other Scalar) bool {
	right, ok := other.(MonthIntervalScalar)
	return ok && s.value == right.value
}

func (s MonthIntervalScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s MonthIntervalScalar) Value() arrow.MonthInterval {
	return s.value
}

func (s MonthIntervalScalar) ValueBytes() []byte {
	b := make([]byte, 4)
	arrow.MonthIntervalTraits.PutValue(b, s.value)
	return b
}

type DayTimeIntervalScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.DayTimeInterval
}

func NewDayTimeIntervalScalar(value arrow.DayTimeInterval, dataType arrow.DataType) DayTimeIntervalScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return DayTimeIntervalScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s DayTimeIntervalScalar) Equals(other Scalar) bool {
	right, ok := other.(DayTimeIntervalScalar)
	return ok && s.value == right.value
}

func (s DayTimeIntervalScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s DayTimeIntervalScalar) Value() arrow.DayTimeInterval {
	return s.value
}

func (s DayTimeIntervalScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.DayTimeIntervalTraits.PutValue(b, s.value)
	return b
}

type DurationScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value arrow.Duration
}

func NewDurationScalar(value arrow.Duration, dataType arrow.DataType) DurationScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return DurationScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s DurationScalar) Equals(other Scalar) bool {
	right, ok := other.(DurationScalar)
	return ok && s.value == right.value
}

func (s DurationScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s DurationScalar) Value() arrow.Duration {
	return s.value
}

func (s DurationScalar) ValueBytes() []byte {
	b := make([]byte, 8)
	arrow.DurationTraits.PutValue(b, s.value)
	return b
}

type Decimal128Scalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value decimal128.Num
}

func NewDecimal128Scalar(value decimal128.Num, dataType arrow.DataType) Decimal128Scalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return Decimal128Scalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s Decimal128Scalar) Equals(other Scalar) bool {
	right, ok := other.(Decimal128Scalar)
	return ok && s.value == right.value
}

func (s Decimal128Scalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s Decimal128Scalar) Value() decimal128.Num {
	return s.value
}

func (s Decimal128Scalar) ValueBytes() []byte {
	b := make([]byte, 16)
	arrow.Decimal128Traits.PutValue(b, s.value)
	return b
}

type ListScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value array.Interface
}

func NewListScalar(value array.Interface, dataType arrow.DataType) ListScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return ListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s ListScalar) Equals(other Scalar) bool {
	right, ok := other.(ListScalar)
	return ok && s.value == right.value
}

func (s ListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s ListScalar) Value() array.Interface {
	return s.value
}

func (s ListScalar) ValueBytes() []byte {
	panic("not implemented")
}

type largeListScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value array.Interface
}

func NewlargeListScalar(value array.Interface, dataType arrow.DataType) largeListScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return largeListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s largeListScalar) Equals(other Scalar) bool {
	right, ok := other.(largeListScalar)
	return ok && s.value == right.value
}

func (s largeListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s largeListScalar) Value() array.Interface {
	return s.value
}

func (s largeListScalar) ValueBytes() []byte {
	panic("not implemented")
}

type MapScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value array.Interface
}

func NewMapScalar(value array.Interface, dataType arrow.DataType) MapScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return MapScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s MapScalar) Equals(other Scalar) bool {
	right, ok := other.(MapScalar)
	return ok && s.value == right.value
}

func (s MapScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s MapScalar) Value() array.Interface {
	return s.value
}

func (s MapScalar) ValueBytes() []byte {
	panic("not implemented")
}

type FixedSizeListScalar struct {
	// The type of the scalar value
	dataType arrow.DataType

	// Whether the value is valid (not null) or not
	isValid bool

	value array.Interface
}

func NewFixedSizeListScalar(value array.Interface, dataType arrow.DataType) FixedSizeListScalar {
	if dataType == nil {
		dataType = arrow.PrimitiveTypes.Int64
	}
	return FixedSizeListScalar{
		isValid:  false,
		dataType: dataType,
	}
}

func (s FixedSizeListScalar) Equals(other Scalar) bool {
	right, ok := other.(FixedSizeListScalar)
	return ok && s.value == right.value
}

func (s FixedSizeListScalar) NotEquals(other Scalar) bool {
	return !s.Equals(other)
}

func (s FixedSizeListScalar) Value() array.Interface {
	return s.value
}

func (s FixedSizeListScalar) ValueBytes() []byte {
	panic("not implemented")
}

var (
	_ Scalar = (*BooleanScalar)(nil)
	_ Scalar = (*Int8Scalar)(nil)
	_ Scalar = (*Int16Scalar)(nil)
	_ Scalar = (*Int32Scalar)(nil)
	_ Scalar = (*Int64Scalar)(nil)
	_ Scalar = (*Uint8Scalar)(nil)
	_ Scalar = (*Uint16Scalar)(nil)
	_ Scalar = (*Uint32Scalar)(nil)
	_ Scalar = (*Uint64Scalar)(nil)
	_ Scalar = (*Float16Scalar)(nil)
	_ Scalar = (*Float32Scalar)(nil)
	_ Scalar = (*Float64Scalar)(nil)
	_ Scalar = (*BinaryScalar)(nil)
	_ Scalar = (*StringScalar)(nil)
	_ Scalar = (*LargeBinaryScalar)(nil)
	_ Scalar = (*LargeStringScalar)(nil)
	_ Scalar = (*FixedSizeBinaryScalar)(nil)
	_ Scalar = (*Date32Scalar)(nil)
	_ Scalar = (*Date64Scalar)(nil)
	_ Scalar = (*Time32Scalar)(nil)
	_ Scalar = (*Time64Scalar)(nil)
	_ Scalar = (*TimestampScalar)(nil)
	_ Scalar = (*MonthIntervalScalar)(nil)
	_ Scalar = (*DayTimeIntervalScalar)(nil)
	_ Scalar = (*DurationScalar)(nil)
	_ Scalar = (*Decimal128Scalar)(nil)
	_ Scalar = (*ListScalar)(nil)
	_ Scalar = (*largeListScalar)(nil)
	_ Scalar = (*MapScalar)(nil)
	_ Scalar = (*FixedSizeListScalar)(nil)
)
